<?php


require_once (__DIR__ . DIRECTORY_SEPARATOR . 'Classes/DupUtil.php');
require_once (__DIR__ . DIRECTORY_SEPARATOR . 'Classes/DupLogs.php');
require_once (__DIR__ . DIRECTORY_SEPARATOR . 'Classes/BackupDatabase.php');


class Duplicator extends WireData implements Module, ConfigurableModule
{
    const DUP_APPLICATION_NAME          = 'Duplicator';
    const DUP_MIN_VERSION               = '2.7.2'; // tested - if you have a lower version please test it and report back your result! thanks
    const DUP_LOG_FILENAME              = 'duplicator';
    const DUP_SITE_FOLDER               = 'site';
    const DUP_DEFAULT_LOCAL_FOLDER      = 'backups';
    const DUP_TEMP_FOLDER               = 'duplicator-temp';
    const DUP_PACKAGE_EXTENSION         = 'package.zip';
    const DUP_PACKAGE_EXTENSION_SHORT   = 'package';
    const DUP_PACKAGE_MIME_TYPE         = 'application/zip';
    const DUP_TIMESTAMP_FORMAT          = 'Y-m-d_H-i-s';
    const DUP_MAX_PACKAGES              = 100;
    const DUP_PHP_MAX_MEMORY            = 512;
    const DUP_DB_MAX_TIME               = 5000;
    const DUP_PHP_EXECUTION_TIME        = 300;
    const DUP_ZIP_FLUSH_TRIGGER         = 1000;

    protected static $_data;

    public static function getModuleInfo()
    {
        return array(
            'title'     => 'Duplicator',
            'version'   => '1.1.7',
            'summary'   => 'Duplicate, backup and transfer an entire site from one location to another.',
            'author'    => 'flydev',
            'href'      => 'https://processwire.com/talk/topic/15345-duplicator-backup-and-move-sites/',
            'singular'  => true,
            'autoload'  => function () {
                return ((wire('input')->get->name == __CLASS__) !== false && wire('page')->template == 'admin');
            },
            'icon' => 'clone'
        );
    }

    protected static function getDefaultData()
    {
        return array(
            'path'           => '',
            'defaultPath'    => '',
            'ignoredPath'    => '',
            'backups'        => 1,
            'backupSessions' => 1,
            'packageName'    => '',
            'cycle'          => 'everyHour',
            'deadline'       => 'never',
            // max number of packages (locally or cloud stored packages)
            'maxPackages'    => self::DUP_MAX_PACKAGES,
            'removeBackups'  => 1,
            // Advanced options
            'archiveFlush'       => 0,
            // CRON mode
            'cronMode'       => 'none',
            // storage mode
            'useLocalFolder' => 1,
            'useFTP'         => 0,
            'useGoogleDrive' => 0,
            'useAmazonS3'    => 0,
            // FTP
            'ftpHostname'    => '',
            'ftpPort'        => '',
            'ftpUsername'    => '',
            'ftpPassword'    => '',
            'ftpDirectory'   => '',
            'ftpTimeout'     => '',
            'ftpSSL'         => 0,
            'ftpPassive'     => 1,
            // Google
            'googleKeyFile'  => '',
            'shareWithEmail' => '',
            // Amazon
            'awsAccessKey'   => '',
            'awsSecretKey'   => '',
            'awsBucketName'  => '',
            'awsRegion'      => ''
        );
    }

    /*
     * constructor
     */
    public function __construct()
    {
        $this->setArray(self::getDefaultData());
        self::$_data = $this;

        $this->moduleDir = $this->config->paths->siteModules . $this->className;

        //$this->config->styles->add($this->config->urls->{$this->className} . "{$this->className}.css");
        //$this->config->scripts->add($this->config->urls->{$this->className} . "{$this->className}.js");

        $this->defaultPath = wire('config')->paths->assets . self::DUP_DEFAULT_LOCAL_FOLDER;
        if (!is_dir($this->defaultPath) && empty($this->path)) {
            wireMkdir($this->defaultPath);
        }
        $this->ignoredPath = wire('config')->paths->assets . self::DUP_DEFAULT_LOCAL_FOLDER;
        $this->maxPackages = ($this->maxPackages && $this->maxPackages <= self::DUP_MAX_PACKAGES) ? $this->maxPackages : self::DUP_MAX_PACKAGES;
    }

    /*
     * module init
     */
    public function init()
    {
        if (wire('input') && wire('input')->get('name') == __CLASS__) {
            $root = $this->config->urls->siteModules . __CLASS__;
            $this->config->styles->prepend($root . '/' . __CLASS__ .'.css');
            $this->config->scripts->add($root . '/' .  __CLASS__ . '.js');
        }

        if($this->useFTP) {
            require_once(__DIR__ . '/Classes/FTPClient.php');
        }

        $file = __DIR__ . '/SDKs/google-api-php-client-2.2.0/src/Google/autoload.php';
        if(file_exists($file)) {
            require_once(/*NoCompile*/ $file);
            require_once(__DIR__ . '/Classes/ClientGoogleDrive.php');
        }
        elseif (class_exists('\Google_Client')) {
            require_once(__DIR__ . '/Classes/ClientGoogleDrive.php');
        }

        $file = __DIR__ . '/SDKs/aws/aws-autoloader.php';
        if(file_exists($file)) {
            require_once(/*NoCompile*/ $file);
            require_once(__DIR__ . '/Classes/ClientAmazonS3.php');
        }
        elseif(class_exists('\Aws\S3\S3Client')) {
            require_once(__DIR__ . '/Classes/ClientAmazonS3.php');
        }

        if (empty($this->path)) {
            $this->path = $this->defaultPath;
        }

        if (!is_dir($this->path) && !empty($this->path)) {
            wireMkdir($this->path);
        }

        if (empty($this->packageName)) {
            $this->packageName = str_replace('-', '_', $this->config->httpHost);
        }

        $action = $this->sanitizer->text($this->input->get->action, array('maxLength' => 20));
        switch ($action) {
            case 'backup_now': {
                $e = new HookEvent();
                $result = $this->cronJob($e);
                //$this->session->redirect($this->config->urls->admin . 'module/edit?name=' . $this->className . '&collapse_info=1');
                break;
            }

            case 'clean_packages':
                DUP_Util::clean($this->path, 0);
                break;

            case 'none':
                break;

            case 'warning': {
                if(!empty($this->input->get->msg))
                    $this->warning(($this->sanitizer->text($this->input->get->msg)));
                break;
            }

            case 'error': {
                $this->error(($this->sanitizer->text($this->input->get->msg)));
                break;
            }

            case 'view_listing':
                echo $this->renderModalPackagesFound();
                break;

            default:
                break;
        }

        switch($this->cronMode) {
            case 'LazyCron':
                if (!$this->modules->isInstalled('LazyCron')) {
                    $this->warning('You must install the core module LazyCron .');
                } else {
                    if ($this->cycle == 'logoutTrigger') {
                        $this->addHookBefore("Session::logout", function () {
                            if (!$this->wire('user')->hasPermission('duplicator')) return;
                            $e = new HookEvent();
                            $this->cronJob($e);
                        });
                    } elseif ($this->cycle == 'submitTrigger') {
                        $this->addHookBefore("InputfieldSubmit::processInput", function (HookEvent $event) {
                            if (!$this->wire('user')->hasPermission('duplicator')) return;
                            $e = new HookEvent();
                            $this->cronJob($e);
                        });
                    } elseif ($this->cycle) {
                        $this->addHook("LazyCron::{$this->cycle}", $this, 'cronJob');
                    }
                }
                break;

            case 'PWCron':
                if (!$this->modules->isInstalled('PwCron')) {
                    $this->warning("You must install the module PWCron. Please read the duplicator's readme");
                } else {
                    $this->addHook('PwCron::cronHook', $this, 'cronJob');
                }
                break;

            case 'none':
            default:
                break;
        }
    }

    /*
     * module ready
     */
    public function ready()
    {

    }

    /*
     * module install
     */
    public function ___install()
    {
        if (version_compare($this->config->version, self::DUP_MIN_VERSION, '<'))
            throw new WireException("This module requires ProcessWire " . self::DUP_MIN_VERSION . " or newer.");
    }

    /*
     * module uninstall
     */
    public function ___uninstall()
    {
        $path = str_replace($this->config->paths->root, '/', $this->path);
        $this->warning("Please note that packages files in {$path} remain. You may remove them manually.");
    }

    public static function getPath()
    {
        return self::$_data->path;
    }

    /*
     * build a ZIP file containing the ProcessWire structure
     * return the ZIP file
     */
    protected function buildProcessWireBackup($options = array())
    {
        $defaultOptions = array(
            'filename' => DUP_Util::formatFilename(wire('config')->httpHost, 'pw' . strrchr(self::DUP_PACKAGE_EXTENSION, '.')),
            'folder' => wireTempDir(self::DUP_TEMP_FOLDER),
            'exclude' => array(),
            'extension' => array()
            //'allowHidden'   => true
        );
        $options = array_merge($options, $defaultOptions);
        $root = str_replace('/', DS, wire('config')->paths->root);
        $path = str_replace('/', DS, wire('config')->paths->root . self::DUP_SITE_FOLDER . DS . basename(wire('config')->paths->assets) . DS);

        array_push($options['exclude'], $path . 'cache' . DS . 'WireTempDir');
        if ($this->backupWire) array_push($options['exclude'], $root . 'wire');
        if ($this->backups) array_push($options['exclude'], $path . 'backups');
        if ($this->backupLogs) array_push($options['exclude'], $path . 'logs');
        if ($this->backupCache) array_push($options['exclude'], $path . 'cache');
        if ($this->backupSessions) array_push($options['exclude'], $path . 'sessions');
        if ($this->backupFiles) array_push($options['exclude'], $path . 'files');

        $excluded = preg_split('/\r\n|[\r\n]/', $this->ignoredPath);
        $options['exclude'] = array_merge($options['exclude'], $excluded);

        foreach ($options['exclude'] as $option) {
            if(!empty($option)) {
                $validExt = ($option[0] === '*' && $option[1] === '.') ? $option : '';
                $ext = substr(strchr($validExt, '.'), 1);
                if (!empty($ext)) array_push($options['extension'], $ext);
                if(is_dir($root . $option)) {
                    array_push($options['exclude'], $root . $option);
                } elseif(is_file($root . $option)) {
                    array_push($options['exclude'], $root . $option);
                }
            }
        }

        foreach ($this->ignoredExtensions as $ignoredExtension) {
            $validExt = substr(strchr($ignoredExtension, '.'), 1);
            if(!empty($validExt)) array_push($options['extension'], $validExt);
        }

        if (!is_dir($options['folder']) || !is_writable($options['folder'])) {
            DUP_Logs::log('- could not create temporary directory: ' . $options['folder']);
            return false;
        }

        $fileinfo['zipfile'] = $options['folder'] . $options['filename'];
        $fileinfo['zipname'] = basename($fileinfo['zipfile']);

        $zipinfo = $this->zipData(wire('config')->paths->root, $fileinfo['zipfile'], $options);
        $fileinfo['structure'] = $zipinfo;

        if (!file_exists($fileinfo['zipfile'])) {
            DUP_Logs::log("- an error occured while building the ProcessWire structure.");
            return false;
        }

        return $fileinfo;
    }

    /*
     * backup the database
     * return the ZIP file containing the SQL file
     */
    protected function buildDatabaseBackup(array $options = array())
    {
        $defaultOptions = array(
            'path' => wireTempDir(self::DUP_TEMP_FOLDER),
            'backup' => array(
                'filename' => DUP_Util::formatFilename(wire('config')->dbName, 'sql'),
                'description' => '', //$this->backupFileinfo(),
                'maxSeconds' => 120
            )
        );
        $options = array_merge($options, $defaultOptions);
        $dbBackup = new BackupDatabase($options);
        $zipobj = $dbBackup->setDatabase($this->database)->setMode('MODE_PWAPI');
        $zipfile = $zipobj->getZip();
        if (file_exists($zipfile)) {
            $fileinfo['zipfile'] = $zipfile;
            $fileinfo['zipname'] = basename($zipfile);
            $fileinfo['sqlsize'] = $zipobj->getSize();
            return $fileinfo;
        }

        return false;
    }

    /*
     * build the package
     * return a ZIP file containing the database and ProcessWire stucture zipped files
     * TODO: better management for future use in deployment
     */
    protected function buildPackage(array $options = array())
    {
        DUP_Util::timer('build');

        $defaultOptions = array(
            'filename' => DUP_Util::formatFilename(str_replace('-', '_', $this->packageName), 'package.zip'),
            'path' => $this->path
        );
        $options = array_merge($options, $defaultOptions);
        $packageInfos = array();

        try {
            $dbbackup = $this->buildDatabaseBackup();
            if ($dbbackup == false) {
                DUP_Logs::log("- an error occured during database backup.");
                return false;
            }
            $packageInfos['db'] = $dbbackup;

            $pwbackup = $this->buildProcessWireBackup();
            if ($pwbackup == false) {
                DUP_Logs::log("- an error occured during package build.");
                return false;
            }
            $packageInfos['pw'] = $pwbackup;

            $files = array(
                $packageInfos['db']['zipfile'],
                $packageInfos['pw']['zipfile']
            );
            $zipfile = $options['path'] . DS . $options['filename'];
            $result = wireZipFile($zipfile, $files);
            foreach ($files as $file) {
                DUP_Util::deleteFile($file);
            }

            foreach ($result['errors'] as $error) {
                DUP_Logs::log("ZIP add failed: $error");
            }

            if (file_exists($zipfile)) {
                $package['zipfile'] = $zipfile;
                $package['size'] = filesize($zipfile);
                $package['info'] = $packageInfos;
                //$fp = fopen($options['path'] . DS . $options['filename'] . '.json', 'w');
                //fwrite($fp, json_encode($package));
                //fclose($fp);
                DUP_Logs::log("- package built successfully in " . DUP_Util::timer('build') . "sec");
                return $package;
            }
            else {
                DUP_Logs::log("- package build failed, {$zipfile} doesn't exist");
                return false;
            }
        } catch (\Exception $ex) {
            DUP_Logs::log($ex->getMessage());
        }

        return true;
    }

    /*
     * call this function from a cron tool to launch the backup task
     */
    public function ___cronJob()
    {
        if (!$this->useLocalFolder && !$this->useGoogleDrive && !$this->useAmazonS3 && !$this->useFTP) {
            return false;
        }

        DUP_Util::timer('job');
        //ignore_user_abort(true);
        DUP_Util::setMemoryLimit(self::DUP_PHP_MAX_MEMORY);
        DUP_Util::setMaxExecutionTime(self::DUP_PHP_EXECUTION_TIME);

        $package = $this->buildPackage();
        if ($package['zipfile'] !== null) {
            $packageName = basename($package['zipfile']);
            if ($this->useLocalFolder) {
                if (file_exists($package['zipfile'])) {
                    DUP_Logs::log("- package saved in local folder: $packageName", 'message');
                } else {
                    DUP_Logs::log("An error occured.");
                }
            }

            if ($this->useFTP) {
                try {
                    $ftp = new \FTPClient();
                    $ftp->setHost($this->ftpHostname);
                    $ftp->setPort(empty($this->ftpPort) ? 21 : $this->ftpPort);
                    $ftp->setUser($this->ftpUsername);
                    $ftp->setPassword($this->ftpPassword);
                    $ftp->setTimeout(empty($this->ftpTimeout) ? 90 : $this->ftpTimeout);
                    ($this->ftpSSL == true) ? $ftp->ssl_connect() : $ftp->connect();
                    $ftp->login();
                    $ftp->pasv($this->ftpPassive);
                    $ftp->setPath($this->ftpDirectory);
                    $ftp->upload(basename($package['zipfile']), $package['zipfile'], $this->ftpDirectory);
                    $ftp->deleteOldBackups($this->maxPackages, $this->deadline);
                    $ftp->disconnect();
                    DUP_Logs::log("- [FTP] package uploaded successfuly: $packageName", 'message');
                } catch (\FTPClientException $ex) {
                    if (@is_resource($ftp)) $ftp->disconnect();
                    DUP_Logs::log("[FTP] error: " . $ex->getMessage(), 'error');
                }
            }

            if ($this->useGoogleDrive) {
                try {
                    if (!class_exists('\Google_Client')) {
                        throw new WireException("GoogleDrive SDK not installed.");
                    }

                    $google = new GoogleDriveClient();
                    $google->setTempFolder(self::DUP_TEMP_FOLDER);
                    $google->setAppName(self::DUP_APPLICATION_NAME);
                    $google->setGoogleKeyFile($this->googleKeyFile);
                    $google->setShareWithEmail($this->shareWithEmail);
                    $google->setMaxPackages($this->maxPackages);
                    $google->connect();
                    $google->upload($package['zipfile']);
                    $files = $google->getPackages(self::DUP_PACKAGE_EXTENSION, self::DUP_PACKAGE_MIME_TYPE, $this->deadline);
                    if(is_array($files) && count($files))  {
                        $google->deleteFiles($files);
                    }
                    //$quota = $google->getStorageQuota();
                    //bd(DUP_Util::human_filesize($quota));
                } catch (\GoogleClientException $ex) {
                    DUP_Logs::log("- [GoogleDrive] error: " . $ex->getMessage(), 'error');
                }
            }

            if ($this->useAmazonS3) {
                try {
                    if (!class_exists('\Aws\S3\S3Client')) {
                        throw new WireException("AmazonS3 SDK not installed.");
                    }

                    $amazonaws = new \AmazonS3Client();
                    $amazonaws->setAccessKey($this->awsAccessKey);
                    $amazonaws->setSecretKey($this->awsSecretKey);
                    $amazonaws->setRegion($this->awsRegion);
                    $amazonaws->setBucket($this->awsBucketName);
                    $buckets = $amazonaws->getBuckets();
                    $bucketExist = false;
                    foreach ($buckets as $bucket) {
                        if (strcmp($bucket, $this->awsBucketName) === 0) {
                            $bucketExist = true;
                            break;
                        }
                    }
                    if (!$bucketExist) $amazonaws->createBucket($this->awsBucketName);
                    $amazonaws->upload($package['zipfile'], $packageName);
                    //if($url === null) throw new AmazonS3ClientException("AmazonS3: An error occured while uploading package <{$packageName}>");
                    $amazonaws->deleteOldBackups($this->maxPackages, $this->deadline);
                } catch(AmazonS3ClientException $ex) {
                    DUP_Logs::log("[AmazonS3] error: " . $ex->getMessage(), 'warning');
                }
            }

            if (!empty($this->deadline) || $this->maxPackages <= DUP_Util::getTotalPackages(self::$_data->path, self::DUP_PACKAGE_EXTENSION) && DUP_Util::getTotalPackages(self::$_data->path, self::DUP_PACKAGE_EXTENSION) != 0) {
                $removed = count(DUP_Util::clean(self::$_data->path, $this->maxPackages, strtotime("-{$this->deadline}")));
                if ($removed > 0) DUP_Logs::log(sprintf("- deleted %d local package%s", $removed, ($removed > 1) ? 's' : ''));
            }

            if($this->removeBackups && !$this->useLocalFolder) {
                if($this->useAmazonS3) {
                    // fix: https://github.com/aws/aws-sdk-php/issues/841
                    // garbage collector's buffer filled, force cycles
                    gc_collect_cycles();
                }
                DUP_Util::deleteFile($package['zipfile']);
            }

        } else {
            DUP_Logs::log("- package build failed.");
            return null;
        }

        DUP_Logs::log("- job finished in " . DUP_Util::timer('job') ."sec");
        return true;
    }

    /**
     * Build a ZIP file
     * @return array
     */
    public function zipData($source, $destination, $excluded = array())
    {
        DUP_Util::timer('zip');

        if($this->archiveFlush == true) {
            DUP_Logs::log('- advanced option activated: ArchiveFlush');
        }

        if (extension_loaded('zip')) {

            $filecount = 0;
            $dircount = 0;
            $size = 0;
            $limitItems = 0;

            if (file_exists($source)) {
                $zip = new \ZipArchive();
                if ($zip->open($destination, \ZIPARCHIVE::CREATE)) {
                    $source = realpath($source);

                    $innerIterator = new RecursiveDirectoryIterator($source, RecursiveDirectoryIterator::SKIP_DOTS);
                    $iterator = new RecursiveIteratorIterator(new DUP_DataFilter($innerIterator, $excluded));

                    foreach ($iterator as $pathname => $fileInfo) {
                        $file = realpath($pathname);
                        $size += filesize($file);
                        if (is_dir($file)) {
                            $dircount++;
                            $zip->addEmptyDir(str_replace($source . '', '', $file . ''));
                        } elseif (is_file($file)) {
                            $filecount++;
                            $zip->addFile($file, str_replace($source . '', '', $file));
                            $limitItems++;

                            if($limitItems > Duplicator::DUP_ZIP_FLUSH_TRIGGER && $this->archiveFlush == true) {

                                $zip->close();
                                DUP_Util::FcgiFlush();
                                $zip->open($destination);
                                //DUP_Logs::log("Items archived [". $limitItems ."] flushing response.");
                                $limitItems = 0;
                            }
                        }
                    }
                }

                $result = $zip->close();
                if($result == false) {
                    DUP_Logs::log('- could not finish creating the (zip) structure, an error occured');
                }

                $infos['files'] = $filecount;
                $infos['dirs'] = $dircount;
                $infos['size'] = $size;

                DUP_Logs::log("- structure zipped successfully in " . DUP_Util::timer('zip') ."sec");

                return $infos;
            }
            else {
                DUP_Logs::log("- the file '{$source}' doesn't exist");
            }
        }
        else {
            DUP_Logs::log("- could not load php zip extension");
        }
        return false;
    }


    /*
     * return various information about local storage
     */
    protected static function getLocalFolderInfo()
    {
        $pkgs = DUP_Util::getTotalPackages(self::$_data->path, self::DUP_PACKAGE_EXTENSION);
        $path = strlen(self::$_data->path) > 0 ? self::$_data->path : self::$_data->defaultPath;
        $infos['markupText'] = "Local folder: invalid directory - the destination path doesn't exist or is not writable";
        //$infos['notes'] = sprintf(__(" » %d package(s) found"), $pkgs);
        if (!empty($path) && is_dir($path)) {
            wire('modules')->get('JqueryUI')->use('modal');
            //$href = wire('config')->urls->admin . "module/edit?name=" . DUP_APPLICATION_NAME . "&action=view_listing";
            $href = wire('config')->urls->admin . "setup/". self::DUP_APPLICATION_NAME ."/?action=packages";
            //$preview = ($pkgs === 0) ? '' : "<a href='{$href}' class='pw-modal'><i class='fa fa-eye'></i> Manage Package(s)</a>";
            $preview = wire('modules')->isInstalled("ProcessDuplicator") ? "<a href='{$href}'><i class='fa fa-eye'></i> Package Manager</a>" : "";
            $infos['markupText'] = sprintf("Local packages overview › <span class='notes'>%s</span><br>Disk space used › \t<span class='notes'>&nbsp;~%s&nbsp;</span><br>Disk space remaining › <span class='notes'>&nbsp;%s/%s&nbsp;</span><br>Package(s) found › <span class='notes'>&nbsp;%d&nbsp;</span> {$preview}",
                self::$_data->path,
                ($pkgs == 0) ? '0' : DUP_Util::human_filesize(DUP_Util::foldersize($path), 0),
                DUP_Util::human_filesize(disk_free_space($path), 0),
                DUP_Util::human_filesize(disk_total_space($path), 0),
                DUP_Util::getTotalPackages(self::$_data->path, self::DUP_PACKAGE_EXTENSION)
            );
        }
        return $infos;
    }

    /*
     * return various information about GoogleDrive storage
     * (ALPHA)
     */
    protected static function getGoogleDriveInfo()
    {
        $pkgs = 0;
        $infos['markupText'] = 'Invalid informations';
        if(class_exists('GoogleDriveClient')) {
            $google = new \GoogleDriveClient();
            $google->setTempFolder(self::DUP_TEMP_FOLDER);
            $google->setAppName(self::DUP_APPLICATION_NAME);
            $google->setGoogleKeyFile(self::$_data->googleKeyFile);
            $google->setShareWithEmail(self::$_data->shareWithEmail);
            $google->connect();
            $quota = $google->getStorageQuota();
            $infos['markupText'] = sprintf("GoogleDrive packages overview › <span class='notes'>%s</span><br>Usage in drive › \t<span class='notes'>&nbsp;~%s&nbsp;</span><br>Drive space remaining › <span class='notes'>&nbsp;%s/%s&nbsp;</span><br>Package(s) found › <span class='notes'>&nbsp;%d&nbsp;</span>",
                'Using GoogleDrive cloud service',
                DUP_Util::human_filesize($quota->usage),
                DUP_Util::human_filesize($quota->limit - ((int)$quota->usage)),
                DUP_Util::human_filesize($quota->limit),
                count($google->getPackages(self::DUP_PACKAGE_EXTENSION, self::DUP_PACKAGE_MIME_TYPE, self::$_data->deadline))
            );
        }
        return $infos;
    }

    public static function getModuleConfigInputfields(array $data)
    {
        $data = array_merge(self::getDefaultData(), $data);

        $config = wire('config');
        $input = wire('input');
        $modules = wire('modules');
        $disabled = 'disabled';
        $skip = false;

        $fields = new InputfieldWrapper();

        // Local info
        $field = $modules->get("InputfieldMarkup");
        $markup = self::getLocalFolderInfo();
        $field->markupText = $markup['markupText'];
        //$field->notes = $markup['notes'];
        //$field->showIf = "useLocalFolder=1";
        $fields->add($field);

        // Google info ALPHA
        /*
        $field = $modules->get("InputfieldMarkup");
        $markup = self::getGoogleDriveInfo();
        $field->markupText = $markup['markupText'];
        //$field->notes = $markup['notes'];
        $field->showIf = "useGoogleDrive=1";
        $fields->add($field);
        */

        /*
         * removed in v0.0.41
         *
        $fsa = $modules->get("InputfieldFieldset");
        $fsa->label = __("Actions");
        $fsa->icon = 'bolt';
        //$fsa->collapsed = Inputfield::collapsedHidden;

        $href = $config->urls->admin . 'module/edit?name=' . self::$_data->className . '&collapse_info=1&action=backup_now';
        $field = $modules->get('InputfieldButton');
        $field->attr('id+name', 'backupNow');
        $field->attr('value', 'Initiate Backup Process');
        $field->attr('data-action', $href);
        $field->icon = 'clone';
        $fsa->append($field);

        if(DUP_Util::getTotalPackages(self::$_data->path, self::DUP_PACKAGE_EXTENSION)) {
            $href = $config->urls->admin . 'module/edit?name=' . self::$_data->className . '&collapse_info=1&action=clean_packages';
            $field = $modules->get('InputfieldButton');
            $field->attr('id+name', 'pruneBackups');
            $field->attr('value', 'Delete All Packages');
            $field->attr('data-action', $href);
            $field->attr('enabled', 'disabled');
            $field->icon = 'trash';
            $fsa->append($field);
        }

        $fields->append($fsa);
        */

        $fs = $modules->get("InputfieldFieldset");
        $fs->label = __("Package settings");
        $fs->icon = 'cogs';
        $fs->description = __("Override module's settings.");
        $fs->collapsed = false;

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'packageName');
        $field->label = __("Name");
        $field->icon = 'file';
        $field->description = __("Name of the final package file - without extension.");
        if ($data['packageName']) $field->attr('value', $data['packageName']);
        $field->collapsed = false;
        $field->notes = 'Default name: {timestamp}-' . $config->httpHost . '.' . self::DUP_PACKAGE_EXTENSION;
        $fs->append($field);

        $field = $modules->get("InputfieldFieldset");
        $field->label = "Files and folders excluded from...";
        $field->description = "Files and folders excluded from the package.";
        $field->icon = 'times-circle';
        //$field->notes = __("");
        $field->collapsed = false;

        $fim = $modules->get("InputfieldMarkup");
        $fim->attr('class', 'warning-notes');
        $fim->markupText = '<p><strong><i class="fa fa-warning"></i> Are you sure you want to include the &laquo;Backups&raquo; folder ?</strong></p>';
        $fim->notes = __('Including this folder will make the final package file growing exponentially.');
        $fim->showIf = "backups=0";
        $field->append($fim);

        $checkboxes = [
            ['name' => 'backupWire', 'label' => 'Wire', 'checked' => (isset($data['backupWire']) && $data['backupWire']) == '1' ? '1' : '0'],
            ['name' => 'backups', 'label' => 'Backups', 'checked' => (isset($data['backups']) && $data['backups']) == '1' ? '1' : '0'],
            ['name' => 'backupLogs', 'label' => 'Logs', 'checked' => (isset($data['backupLogs']) && $data['backupLogs']) == '1' ? '1' : '0'],
            ['name' => 'backupSessions', 'label' => 'Sessions', 'checked' => (isset($data['backupSessions']) && $data['backupSessions']) == '1' ? '1' : '0'],
            ['name' => 'backupCache', 'label' => 'Cache', 'checked' => (isset($data['backupCache']) && $data['backupCache']) == '1' ? '1' : '0'],
            ['name' => 'backupFiles', 'label' => 'Files', 'checked' => (isset($data['backupFiles']) && $data['backupFiles']) == '1' ? '1' : '0']
        ];
        foreach ($checkboxes as $checkbox) {
            $cb = $modules->get('InputfieldCheckbox');
            $cb->attr('name', $checkbox['name']);
            $cb->label = $checkbox['label'];
            $cb->columnWidth = 16;
            $cb->attr('checked', $checkbox['checked'] == '1' ? 'checked' : '');
            $field->append($cb);
        }

        $fim = $modules->get("InputfieldMarkup");
        $fim->attr('class', 'pw-notes');
        $fim->markupText = '<p class="notes">Shortcuts: Wire refer to the root <span><strong>&laquo;wire/&raquo;</strong></span> folder. Backups, Logs, Sessions, Cache and Files refer to <span><strong>&laquo;site/assets/&raquo;</strong></span></p>';
        $field->append($fim);

        $ta = $modules->get("InputfieldTextarea");
        $ta->attr('name', 'ignoredPath');
        $ta->label = "Custom excluded files and paths";
        $ta->value = $data['ignoredPath'];
        $ta->collapsed = false;
        $ta->notes = 'Enter absolute or relative path. One (1) extension, filename or path per line. To exclude extension: *.foo';
        $ta->columnWidth = 50;
        $field->append($ta);

        $f = $modules->get('InputfieldAsmSelect');
        $f->name = 'ignoredExtensions';
        $f->label = __('Filetype exclusions');
        $f->description = __('Default set of extensions to exclude.');
        $f->collapsed = Inputfield::collapsedNever;
        $f->columnWidth = 50;
        $f->addOption('*.pdf', 'PDF');
        $f->addOption('*.mp3', 'MP3');
        $f->addOption('*.jpg', 'JPG');
        $f->addOption('*.png', 'PNG');
        $f->addOption('*.zip', 'ZIP');
        $f->addOption('*.tar', 'TAR');
        $f->addOption('*.gz', 'TAR GUNZIP');
        $f->addOption('*.tgz', 'TGZ');
        $f->addOption('*.rar', 'RAR');

        if (isset($data[ $f->name ]) && $data[ $f->name ]) {
            $f->attr('value', $data[ $f->name ]);
        }
        $field->append($f);

        $fs->append($field);

        $field = $modules->get('InputfieldInteger');
        $field->attr('name', 'maxPackages');
        $field->value = $data['maxPackages'];
        $field->icon = 'signal';
        $field->attr('min', 1);
        $field->attr('max', self::DUP_MAX_PACKAGES);
        $field->attr('type', 'number');
        $field->set('collapsed', true);
        $field->label = __('Maximum number of packages');
        $field->description = __('How many packages do you want to keep in the storage directory ?');
        $field->notes = sprintf(__("max value: %d"), self::DUP_MAX_PACKAGES);
        $field->columnWidth = 50;
        $field->collapsed = false;
        $fs->add($field);

        $cb = $modules->get('InputfieldCheckbox');
        $cb->attr('name', 'removeBackups');
        $cb->icon = 'trash';
        $cb->label = 'Remove package after build';
        $cb->description = 'If checked, the package will be removed after a successful build and only if &laquo;Local Folder&raquo; storage is unchecked.';
        $cb->columnWidth = 50;
        $cb->attr('checked', $data['removeBackups'] == '1' ? 'checked' : '');
        $fs->append($cb);

        $fields->append($fs);

        $fs = $modules->get("InputfieldFieldset");
        $fs->label = __("Cron and timing settings");
        $fs->icon = 'clock-o';
        $fs->collapsed = false;

        $field = $modules->get("InputfieldRadios");
        $field->label = __("Select a mode for running cron jobs");
        $field->attr('id+name', 'cronMode');
        $mod = $modules->isInstalled('LazyCron') ? '(installed)' : '(not installed)';
        $field->addOption('LazyCron', __("LazyCron - Triggered by a pageview {$mod}"));
        $mod = $modules->isInstalled('PwCron') ? " (installed)" : ' (not installed)';
        $field->addOption('PWCron', __("PWCron - Cron or equivalent system required {$mod}"));
        $field->addOption('none', 'None');
        $field->attr('value', is_null($data['cronMode']) ? 'none' : $data['cronMode']);
        $field->notes = __("To use the built-in cron feature, call \"**/webroot/yourwebsite/site/modules/Duplicator/cron.php**\" from your system cron.");
        $fs->append($field);

        $field = $modules->get("InputfieldSelect");
        $field->attr('name', 'cycle');
        $field->attr('class', 'invisble');
        $field->label = __("Event trigger");
        $field->icon = 'refresh';
        $field->description = __("Select a time interval for automated LazyCron backups.");
        if ($data['cycle'] == 'logoutTrigger') $field->notes = __("The cronjob to backup your database executes only if current user has db-backup permission.");
        $field->addOptions(array(
            0 => __('Trigger disabled'),
            //'every30Seconds' => __('30 seconds [dev]'), // dev use
            //'every2Minutes' => '2 minutes [dev]',
            //'every5Minutes' => '5 minutes [dev]',
            //'every10Minutes' => '10 minutes [dev]',
            //'submitTrigger' => __('OnSubmit  [dev]'), // dev use
            'everyHour' => __('1 hour'),
            'every6Hours' => __('6 hours'),
            'everyDay' => __('1 day'),
            'every2Days' => __('2 days'),
            'everyWeek' => __('1 week'),
            'every2Weeks' => __('2 weeks'),
            'every4Weeks' => __('4 weeks'),
            'logoutTrigger' => __('logout trigger')
        ));
        if ($input->post->cycle && $input->post->cycle != $data['cycle']) $field->message(__('Backup cycle interval changed to') . ' ' . $input->post->cycle);
        $field->value = $data['cycle'];
        $field->notes = "This setting does not apply to PWCron.";
        $fs->add($field);

        $field = $modules->get("InputfieldSelect");
        $field->attr('name', 'deadline');
        $field->label = __('Remove backup packages older than');
        $field->icon = 'calendar';
        $field->description = __("Select a time interval after a backup will be deleted sustainably by the cron job.");
        $field->set('collapsed', true);
        $field->addOptions(array(
            null => __('never'),
            '1 minute' => __('1 minute'), // for development use
            '1 day' => __('1 day'),
            '1 week' => __('1 week'),
            '1 month' => __('1 month'),
            '1 year' => __('1 year'),
        ));
        $field->value = $data['deadline'];
        $field->collapsed = false;
        $fs->add($field);

        $fields->append($fs);

        $fs = $modules->get("InputfieldFieldset");
        $fs->label = __("Advanced Settings");
        $fs->icon = 'user-md';
        $fs->collapsed = false;

        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'archiveFlush');
        $field->label = 'Archive Flush: Attempt Network Keep Alive';
        $field->description = 'This will attempt to keep a network connection established for large archives.';
        $field->attr('checked', $data['archiveFlush'] == '1' ? 'checked' : '');
        $fs->append($field);

        $fields->append($fs);

        $fs = $modules->get("InputfieldFieldset");
        $fs->label = "Save package to";
        $fs->icon = 'cloud';
        $fs->collapsed = false;

        // LOCAL
        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'useLocalFolder');
        $field->label = 'Local folder';
        $field->attr('checked', $data['useLocalFolder'] == '1' ? 'checked' : '');
        $fs->append($field);

        $fslocalfolder = $modules->get("InputfieldFieldset");
        $fslocalfolder->label = "Local folder settings";
        $fslocalfolder->description = "Save packages to a local folder.";
        $fslocalfolder->icon = 'folder-open';
        $fslocalfolder->collasped = true;
        $fslocalfolder->showIf = "useLocalFolder=1";

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'path');
        $field->label = __("Path");
        $field->description = __('Absolute path of the directory where packages are saved.');
        $field->value = $data['path'];
        $field->notes = 'Default path: ' . self::$_data->defaultPath;
        $fslocalfolder->append($field);

        $fs->append($fslocalfolder);

        // FTP
        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'useFTP');
        $field->label = 'FTP';
        $field->attr('checked', $data['useFTP'] == '1' ? 'checked' : '');
        $fs->append($field);

        $fsftp = $modules->get("InputfieldFieldset");
        $fsftp->label = "FTP Settings";
        $fsftp->description = "Save packages to FTP server.";
        $fsftp->icon = 'exchange';
        $fsftp->collasped = true;
        $fsftp->showIf = "useFTP=1";

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'ftpHostname');
        $field->label = __("Hostname");
        $field->value = $data['ftpHostname'];
        $field->columnWidth = 50;
        $fsftp->append($field);

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'ftpUsername');
        $field->label = __("Username");
        $field->value = $data['ftpUsername'];
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'ftpPassword');
        $field->label = __("Password");
        $field->value = $data['ftpPassword'];
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'ftpPort');
        $field->label = __("Port");
        $field->description = __("Default: 21");
        $field->value = $data['ftpPort'];
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'ftpTimeout');
        $field->label = __("Timeout");
        $field->description = __("Default: 90 seconds");
        $field->value = $data['ftpTimeout'];
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'ftpSSL');
        $field->label = __("Use SSL/TLS");
        $field->description = __("Cryptographic protocols");
        $field->attr('checked', $data['ftpSSL'] == '1' ? 'checked' : '');
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'ftpPassive');
        $field->label = __("Passive Mode");
        $field->description = __("Passive connection");
        $field->attr('checked', $data['ftpPassive'] == '1' ? 'checked' : '');
        $field->columnWidth = 25;
        $fsftp->append($field);

        $field = $modules->get("InputfieldText");
        $field->attr('name', 'ftpDirectory');
        $field->label = __("Upload directory");
        $field->description = __("Directory on the server where the packages will be stored.");
        $field->value = $data['ftpDirectory'];
        $field->notes = __("Example: backups/subdir/anothersubdir");
        $field->columnWidth = 100;
        $fsftp->append($field);

        $fs->append($fsftp);

        // GOOGLE DRIVE
        if(!class_exists('GoogleDriveClient')) {
            $skip = true;
        }
        $description = ($skip == false) ? $disabled = '' : __("The required SDK is not installed. You can download it [here](https://github.com/flydev-fr/duplicator-google-drive) or install it with [Composer](https://getcomposer.org/doc/00-intro.md). Run **composer require google/apiclient**");
        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'useGoogleDrive');
        $field->label = 'Google Drive';
        $field->description = $description;
        $field->attr('checked', ($data['useGoogleDrive'] == '1' && empty($disabled)) ? 'checked' : '');
        $field->attr('disabled', $disabled);
        $fs->append($field);
        $disabled = 'disabled';
        $skip = false;

        $fsgd = $modules->get("InputfieldFieldset");
        $fsgd->label = "Google Drive settings";
        $fsgd->description = "Save packages to GoogleDrive.";
        $fsgd->icon = 'google';
        $fsgd->showIf = "useGoogleDrive=1";

        $field = $modules->get('InputfieldTextarea');
        $field->name = "googleKeyFile";
        $field->label = __("Key File");
        $field->description = __("Paste here the content of the JSON Key file of your service account. You can obtain the credentials [here](https://console.developers.google.com/apis/credentials) ([How to get a key ?](https://processwire.com/talk/topic/15345-duplicator-backup-and-move-sites/?page=2#comment-139376)).");
        $field->value = $data['googleKeyFile'];
        $fsgd->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'shareWithEmail');
        $field->label = __("Email address");
        $field->description = __("Enter the email address of the contact with whom you want to share the files.");
        $field->value = $data['shareWithEmail'];
        $fsgd->append($field);
        $fs->append($fsgd);

        // AMAZON
        if(!class_exists('AmazonS3Client')) {
            $skip = true;
        }
        $description = ($skip == false) ? $disabled = '' : __("The required SDK is not installed. You can download it [here](https://github.com/flydev-fr/duplicator-amazon-s3) or install it with [Composer](https://getcomposer.org/doc/00-intro.md). Run **composer require aws/aws-sdk-php**");
        $field = $modules->get('InputfieldCheckbox');
        $field->attr('name', 'useAmazonS3');
        $field->label = 'Amazon S3';
        $field->description = $description;
        $field->attr('checked', ($data['useAmazonS3'] == '1' && empty($disabled)) ? 'checked' : '');
        $field->attr('disabled', $disabled);
        $fs->append($field);
        $disabled = 'disabled';
        $skip = false;

        $fsaws = $modules->get("InputfieldFieldset");
        $fsaws->label = "Amazon settings";
        $fsaws->description = "Save packages to AmazonS3.";
        $fsaws->icon = 'amazon';
        $fsaws->showIf = "useAmazonS3=1";

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'awsAccessKey');
        $field->label = __("Access Key ID");
        $field->description = __('You can obtain the credentials [here](https://console.aws.amazon.com/iam/home?#/users).');
        $field->value = $data['awsAccessKey'];
        $field->columnWidth = 50;
        $fsaws->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'awsSecretKey');
        $field->label = __("Secret Key");
        $field->description = __("User secret key.");
        $field->value = $data['awsSecretKey'];
        $field->columnWidth = 50;
        $fsaws->append($field);

        $field = $modules->get('InputfieldText');
        $field->attr('name', 'awsBucketName');
        $field->label = __("Bucket Name");
        $field->description = __("The bucket where the packages will be stored.");
        $field->notes = __("The bucket will be created automatically if not found.");
        $field->value = $data['awsBucketName'];
        $field->columnWidth = 70;
        $fsaws->append($field);

        // http://docs.aws.amazon.com/general/latest/gr/rande.html#s3_region
        $field = $modules->get("InputfieldSelect");
        $field->attr('name', 'awsRegion');
        $field->label = __("Region");
        $field->description = __("Select a region");
        $field->notes = __("Last update: 2017-08-12");
        $field->addOptions(array(
            'us-east-1' => 'US East (N. Virginia)',
            'us-east-2' => 'US East (Ohio)',
            'us-west-1' => 'US West (N. California)',
            'us-west-2' => 'US West (Oregon)',
            'ca-central-1' => 'Canada (Central)',
            'ap-south-1' => 'Asia Pacific (Mumbai)',
            'ap-northeast-2' => 'Asia Pacific (Seoul)',
            'ap-southeast-1' => 'Asia Pacific (Singapore)',
            'ap-southeast-2' => 'Asia Pacific (Sydney)',
            'ap-northeast-1' => 'Asia Pacific (Tokyo)',
            'eu-central-1' => 'EU (Frankfurt)',
            'eu-west-1' => 'EU (Ireland)',
            'eu-west-2' => 'EU (London)',
            'sa-east-1' => 'South America (São Paulo)'
        ));
        $field->value = $data['awsRegion'];
        $field->columnWidth = 30;
        $fsaws->add($field);
        $fs->append($fsaws);

        // Donation button
        /*
        $field = $modules->get("InputfieldMarkup");
        $markup = '<img src="' . $config->urls->{self::$_data->className} .'/Assets/paypal-donate-btn.png" class="donate-btn">';
        $field->markupText = $markup;
        $fs->append($field);
        */

        $fields->append($fs);



        return $fields;
    }
}